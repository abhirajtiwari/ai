import smbus
import time
import math

bus = smbus.SMBus(1)

def twos_complement(val, bits):
    if (val & (1 << (bits - 1))) != 0:
        val = val - (1 << bits)
    return val

bus.write_byte_data(0x1E, 0x20, 0b01100100)
bus.write_byte_data(0x1E, 0x21, 0b00000000)
bus.write_byte_data(0x1E, 0x22, 0b00000000)
bus.write_byte_data(0x1E, 0x23, 0b00001100)


while(True):

	out_x_m_l = bus.read_byte_data(0x1E, 0x28)
	out_x_m_h = bus.read_byte_data(0x1E, 0x29)
	x = twos_complement((out_x_m_h << 8) | out_x_m_l, 16) / 1e3
	#print("X=", x, "gauss")



	out_y_m_l = bus.read_byte_data(0x1E, 0x2A)
	out_y_m_h = bus.read_byte_data(0x1E, 0x2B)
	y= twos_complement((out_y_m_h << 8) | out_y_m_l, 16) / 1e3
	#print("Y=", y, "gauss")


	out_z_m_l = bus.read_byte_data(0x1E, 0x2C)
	out_z_m_h = bus.read_byte_data(0x1E, 0x2D)
	z = twos_complement((out_z_m_h << 8) | out_z_m_l, 16) / 1e3
	#print("Z=",z, "gauss")

	print("")
	print("HEADING:",math.atan(y/x))

	#HARD IRON DISTORTION

	offset_x = (max(x) + min(x)) / 2
	offset_y = (max(y) + min(y)) / 2
	offset_z = (max(z) + min(z)) / 2

	corrected_x =  x - offset_x
	corrected_y =  y - offset_y
	corrected_z =  z - offset_z

	print("X=", corrected_x, "gauss")
	print("Y=", corrected_y, "gauss")
	print("Z=", corrected_z, "gauss")



