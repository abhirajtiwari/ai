import math
import smbus
import time
from gps3 import gps3
import numpy as np

min_x=0
max_x=0
min_y=0
max_y=0
min_z=0
max_z=0

l=293

bus = smbus.SMBus(1)

def twos_complement(val, bits):
    if (val & (1 << (bits - 1))) != 0:
        val = val - (1 << bits)
    return val

bus.write_byte_data(0x1E, 0x20, 0b01111100)
bus.write_byte_data(0x1E, 0x21, 0b00000000)
bus.write_byte_data(0x1E, 0x22, 0b00000000)
bus.write_byte_data(0x1E, 0x23, 0b00001100)


lat2 = 13.347906667
lon2 = 74.792238333
lat1 = 0.0000000
lon1 = 0.0000000





def haversine(lat1, lon1, lat2, lon2):
    # distance between latitudes
    # and longitudes
    dLat = (lat2 - lat1) * math.pi / 180.0
    dLon = (lon2 - lon1) * math.pi / 180.0

    # convert to radians
    lat1 = (lat1) * math.pi / 180.0
    lat2 = (lat2) * math.pi / 180.0

    # apply formulae
    a = (pow(math.sin(dLat / 2), 2) +
         pow(math.sin(dLon / 2), 2) *
         math.cos(lat1) * math.cos(lat2))
    rad = 6378.1*1000
    c = 2 * math.asin(math.sqrt(a))
    dist= rad*c

    if dist < 7:
        print("GATE REACHED")
        quit()

    print("DISTANCE=", dist)


def bearing(lat1, lon1, lat2, lon2):
    dLon = lon2 - lon1
    y = math.sin(dLon) * math.cos(lat2)
    x = math.cos(lat1) * math.sin(lat2) \
        - math.sin(lat1) * math.cos(lat2) * math.cos(dLon)

    degree = math.atan2(y, x) * 180 / math.pi

    if degree < 0:
        degree += 360
    return degree

def roverheading(min_x,max_x,min_y,max_y,min_z,max_z):
    out_x_m_l = bus.read_byte_data(0x1E, 0x28)
    out_x_m_h = bus.read_byte_data(0x1E, 0x29)
    x = twos_complement((out_x_m_h << 8) | out_x_m_l, 16) / 1e3


    out_y_m_l = bus.read_byte_data(0x1E, 0x2A)
    out_y_m_h = bus.read_byte_data(0x1E, 0x2B)
    y = twos_complement((out_y_m_h << 8) | out_y_m_l, 16) / 1e3

    out_z_m_l = bus.read_byte_data(0x1E, 0x2C)
    out_z_m_h = bus.read_byte_data(0x1E, 0x2D)
    z = twos_complement((out_z_m_h << 8) | out_z_m_l, 16) / 1e3

    print("")

    if x < min_x:
        min_x = x
    if x > max_x:
        max_x = x

    if y < min_y:
        min_y = y
    if y > max_y:
        max_y = y

    if z < min_z:
        min_z = z
    if z > max_z:
        max_z = z

    offset_x = (max_x + min_x) / 2
    offset_y = (max_y + min_y) / 2
    offset_z = (max_z + min_z) / 2

    x = x - offset_x
    y = y - offset_y
    z = z - offset_z

    heading = math.atan2(y, x) * 180 / math.pi

    if heading < 0:
        heading += 360

    heading = (heading+l)% 360
    return heading


def displaydata(t):


    if t<10 and t>-10:
       print("STRAIGHT")

    elif t<=-180:
        print("ANTICLOCKWISE",360+t)

    elif t<0 and t>-180:
        print("CLOCKWISE",-t)

    elif t>=180:
        print("CLOCKWISE",360-t)

    elif t>0 and t<180:
        print("ANTICLOCKWISE",t)



gps_socket = gps3.GPSDSocket()
data_stream = gps3.DataStream()
gps_socket.connect()
gps_socket.watch()


for new_data in gps_socket:
        if new_data:
            data_stream.unpack(new_data)
            lat1= data_stream.TPV['lat']
            lon1= data_stream.TPV['lon']
            if lat1 == 'n/a':
                continue
            if lon1 == 'n/a':
                continue

            haversine(lat1, lon1, lat2, lon2)
            a = np.round(bearing(lat1, lon1, lat2, lon2))
            b = np.round(roverheading(min_x, max_x, min_y, max_y, min_z, min_z))
            t = b - a
         displaydata(t)
