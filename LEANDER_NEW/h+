import math
import smbus
import time
from gps3 import gps3

min_x=0
max_x=0
min_y=0
max_y=0
min_z=0
max_z=0

bus = smbus.SMBus(1)

def twos_complement(val, bits):
    if (val & (1 << (bits - 1))) != 0:
        val = val - (1 << bits)
    return val

bus.write_byte_data(0x1E, 0x20, 0b01111100)
bus.write_byte_data(0x1E, 0x21, 0b00000000)
bus.write_byte_data(0x1E, 0x22, 0b00000000)
bus.write_byte_data(0x1E, 0x23, 0b00001100)


lat2 = 13.347841667
lon2 = 74.792141667
lat1 = 0.0000000
lon1 = 0.0000000





def haversine(lat1, lon1, lat2, lon2):
    # distance between latitudes
    # and longitudes
    dLat = (lat2 - lat1) * math.pi / 180.0
    dLon = (lon2 - lon1) * math.pi / 180.0

    # convert to radians
    lat1 = (lat1) * math.pi / 180.0
    lat2 = (lat2) * math.pi / 180.0

    # apply formulae
    a = (pow(math.sin(dLat / 2), 2) +
         pow(math.sin(dLon / 2), 2) *
         math.cos(lat1) * math.cos(lat2))
    rad = 6378.1*1000
    c = 2 * math.asin(math.sqrt(a))
    print((rad * c),"M")

def bearing(lat1, lon1, lat2, lon2):
    dLon = lon2 - lon1
    y = math.sin(dLon) * math.cos(lat2)
    x = math.cos(lat1) * math.sin(lat2) \
        - math.sin(lat1) * math.cos(lat2) * math.cos(dLon)

    degree = math.atan2(y, x) * 180 / math.pi

    if degree < 0:
        degree += 360
    print(degree)






gps_socket = gps3.GPSDSocket()
data_stream = gps3.DataStream()
gps_socket.connect()
gps_socket.watch()

for new_data in gps_socket:
        if new_data:
            data_stream.unpack(new_data)
            lat1= data_stream.TPV['lat']
            lon1= data_stream.TPV['lon']
            if lat1 == 'n/a':
                continue
            if lon1 == 'n/a':
                continue

            bearing(lat1, lon1, lat2, lon2)
            haversine(lat1, lon1, lat2, lon2)

            out_x_m_l = bus.read_byte_data(0x1E, 0x28)
            out_x_m_h = bus.read_byte_data(0x1E, 0x29)
            x = twos_complement((out_x_m_h << 8) | out_x_m_l, 16) / 1e3
            #print("X=", x, "gauss")



            out_y_m_l = bus.read_byte_data(0x1E, 0x2A)
            out_y_m_h = bus.read_byte_data(0x1E, 0x2B)
            y= twos_complement((out_y_m_h << 8) | out_y_m_l, 16) / 1e3
            #print("Y=", y, "gauss")


            out_z_m_l = bus.read_byte_data(0x1E, 0x2C)
            out_z_m_h = bus.read_byte_data(0x1E, 0x2D)
            z = twos_complement((out_z_m_h << 8) | out_z_m_l, 16) / 1e3
            #print("Z=",z, "gauss")

            print("")

            if x< min_x:
                min_x=x
            if x>max_x:
                max_x=x

            if y< min_y:
                min_y=y
            if y>max_y:
                max_y=y

            if z< min_z:
                min_z=z
            if z>max_z:
                max_z=z

            offset_x= (max_x + min_x) / 2
            offset_y =(max_y + min_y) / 2
            offset_z =(max_z + min_z) / 2

            x=x-offset_x
            y=y-offset_y
            z=z-offset_z


            heading= math.atan2(y,x)*180/math.pi

            if heading<0:
                heading +=360



            print("HEADING:", heading)
